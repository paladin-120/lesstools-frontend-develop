import axios from 'axios';

import rootStore from '../../store/store';
import { REACT_APP_CRYPTOCOMPARE_API_KEY } from '../../config/index';
import { TradingviewExchangesNames } from '../../config/exchanges';
import { getCandlesFromOurBackend } from './getCandlesFromOurBackend';

const api_root = 'https://min-api.cryptocompare.com';
const history: any = {};
const api_key = REACT_APP_CRYPTOCOMPARE_API_KEY;


const resolutions = {
  '1': 30000,
  '3': 20000,
  '5': 15000,
  '15': 10000,
  '30': 750,
  '60': 1440,
  '120': 10800,
  '240': 1800,
  '1D': 1800,
  '1W': 1800,
};


interface IExchange {
  [key: string]: {
    markets: Array<string>;
  };
}

interface IExchanges {
  [key: string]: IExchange;
}

const findExchangeForPair = (exchanges: IExchanges, firstSymbolInPair: string) => {
  if (exchanges[firstSymbolInPair]) {
    const secondSymbolsInPair = exchanges[firstSymbolInPair];
    const symbolWithUsd = Object.keys(secondSymbolsInPair).find(
      (symbol) => symbol.startsWith('USD') || symbol.endsWith('USD'),
    );

    if (symbolWithUsd) {
      return {
        symbols: [firstSymbolInPair, symbolWithUsd],
        exchange: secondSymbolsInPair[symbolWithUsd].markets[0],
      };
    }

    const secondSymbol = Object.keys(secondSymbolsInPair)[0];
    return {
      symbols: [firstSymbolInPair, secondSymbol],
      exchange: secondSymbolsInPair[secondSymbol].markets[0],
    };
  }

  return null;
};


export default {
  history,

  getBars: async (
    symbolInfo: any,
    resolution: '1' | '3' | '5' | '15' | '30' | '60' | '120' | '240' | '1D' | '1W',
    from: any,
    to: any,
    first: any,
    limit: any,
  ) => {
    if (!first) return [];
    try {
      const split_symbol: Array<string> = symbolInfo.name.split(/[:/]/);
      const locationPathname = window.location.pathname.split('/');
      const pair_id = locationPathname[locationPathname.length - 1];
      const pool = TradingviewExchangesNames[rootStore.currentExchange.exchange] || 'mainnet';

      // query data from our api
      if (split_symbol[1] !== 'USD') {
        return await getCandlesFromOurBackend({ pair_id, pool, time_interval: resolution });
      }

      // query data from third-party backend
      const url = resolutions[resolution];
      const params = {
        fsym: split_symbol[0],
        tsym: split_symbol[1],
        limit: limit || 2000,
        api_key,
      };

      const result = await axios.get(`${api_root}${url}`, { params });
      const olderData = await axios.get(`${api_root}${url}`, {
        params: { ...params, toTs: result.data.TimeFrom },
      });

      const { data } = result;

      if (data.Response && data.Response === 'Error') {
        const exchanges = await axios.get(`${api_root}/data/cccagg/pairs/excluded`);
        const newRequestData = findExchangeForPair(exchanges.data.Data, split_symbol[0]);
        if (newRequestData) {
          const newBars = await axios.get(`${api_root}${url}`, {
            params: {
              fsym: newRequestData.symbols[0],
              tsym: newRequestData.symbols[1],
              limit: limit || 2000,
              api_key,
              e: newRequestData.exchange,
            },
          });

          return newBars.data.Data.reduce((res: Array<any>, el: any) => {
            if (el.open !== 0) {
              res.push({
                time: el.time * 1000, // TradingView requires bar time in ms
                low: el.low,
                high: el.high,
                open: el.open,
                close: el.close,
                volume: el.volumefrom,
              });
            }

            return res;
          }, []);
        }

        rootStore.modals.open('Info', 'Not enough data to display the graph or very little');
        // query data from our api
        return await getCandlesFromOurBackend({ pair_id, pool, time_interval: resolution });
      }

      if (data.Data.length) {
        const bars = [...olderData.data.Data, ...data.Data].reduce((res: Array<any>, el: any) => {
          if (el.open !== 0) {
            res.push({
              time: el.time * 1000, // TradingView requires bar time in ms
              low: el.low,
              high: el.high,
              open: el.open,
              close: el.close,
              volume: el.volumefrom,
            });
          }

          return res;
        }, []);

        if (first) {
          const lastBar = bars[bars.length - 1];
          history[symbolInfo.name] = { lastBar };
        }
        return bars;
      }
      rootStore.modals.open('Info', 'Not enough data to display the graph or very little');
      return [];
    } catch (e) {
      rootStore.modals.open('Info', 'Not enough data to display the graph or very little');
      return [];
    }
  },
};
